# HTML5



- 第一行：声明文档：标准、怪异

    ```html
    <!DOCTYPE html>
    ```

- 语义化标签、移除过时的显示效果标记

- 多媒体元素、video、audio

- 新的表单控件、date、time

- canvas

- API：文件读取、位置/网络信息、存储（本地离线存储、本地数据库存储）





## 事件流：捕获冒泡

1. 顺序先捕获再冒泡

2. 讲的顺序

   1. 第一讲冒泡`p -> div -> body -> html -> document`
   2. 第二讲捕获`document -> html -> body -> div -> p`

3. 如果就是指本被点击元素，

   捕获不会在冒泡之前，而是绑定的监听事件的顺序

#### 阻止冒泡

在事件处理函数中：

- `event.stopPropagation()`
- 返回 false  ，不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)
-  `event.target==event.currentTarget`，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡；

#### 阻止默认事件

- `event.preventDefault( )`
- return false



### addEvenListener 第三个参数

默认值- false- 事件默认在**冒泡**阶段执行

是true，则按照事件捕获的顺序执行

```html
<body>
　　<div id="box">
　　　　<div id="child"></div>
　　</div>
</body>
```

```js
box.addEventListener("click", function () {
    console.log("box");
})

child.addEventListener("click", function () {
    console.log("child");
})
// child
// box
```

添加true，事件执行顺序变成捕获顺序：box->child，所以box 先执行

```js
box.addEventListener("click", function () {
    console.log("box");
},true)

child.addEventListener("click", function () {
    console.log("child");
})
// box
// child
```





> on 和 addEventListener 的区别？
>
> - onclick会覆盖
>
> - addEventListener 可以无限添加事件

### 事件代理

绑定事件在父元素上，子元素触发判断当前target

# JS阻塞DOM渲染

默认：一读到JS就加载并执行

- 推迟加载：把CSS、JS放末尾

- defer ，延迟加载，效果和上面一样（DOMContentLoaded ），可以保证顺序
- async异步加载：一下载完就执行，不保证执行顺序
- 动态创建script（window.onload）













# DOM解析、渲染的阻塞

> 解析是指浏览器生成 DOM 树结构（此时用户不一定能看到，但脚本比如 `querySelectorAll` 可以访问到）
>
> 渲染是指浏览器把 DOM 树与 CSS 结合进行布局并绘制到屏幕（此时用户是可以看到的）

## DOM渲染流程

1. 下载HTML，解析DOM
2. 遇到CSS`link[rel=stylesheet]`时，加入并行下载队列，继续解析DOM
3. 遇到JS，暂停DOM解析，**立刻下载JS**，并执行，在其中可以访问当前脚本前的DOM
4. JS结束，主线程回到渲染侧，继续解析DOM
5. DOM解析完成，触发`DOMContentLoaded`事件



> 很多被墙的网站加载及其缓慢就是因为DOM主体前有脚本被挡在墙外了。



阻塞：

- 遇到CSS，事件循环进入 渲染侧，JS也会停下。会先解析CSS树，再与DOM 树结合渲染，所以DOM 树渲染会停下，解析不会停。

- 遇到JS 时，**立刻下载JS**，事件循环进入JS侧执行，DOM渲染/解析都会停下



![img](assets/0.HTML/pre-party.png)

串行，前面延迟后影响后面

浏览器在这方面已经做了很多优化，例如它会猜测你将要打开的页面，并预先解析 DNS 甚至直接下载它们。

优化点：

- 渲染阻塞

  - CSS在上，JS在下，异步载入

  - CSS添加媒体查询，减少阻塞

    优化：响应式站点可以添加媒体查询，来避免不必要的阻塞。

    ```html
    <link href="other.css" rel="stylesheet" media="(min-width: 40em)">
    ```

  - 设置script 属性

    - `defer`推迟，让该JS在 `DOMContentLoaded` 前执行。
    - **`async`** 并行请求

  

- 资源并发限制，添加`prefetch`，`prerender`

  - dns 预解析

    对重定向也有用，host1.com/resource > 301 > host2.com/resource ，设置 `dns-prefetch: host2.com`

  ```html
    <link rel='dns-prefetch' href='example.com'>
  ```

  - http 预加载

    `prefetch` 优先级最低

  ```html
    <link rel="prefetch" href="checkout.html">
  ```

  - 子资源subresource

    浏览器会在当前访问页面时立即下载它们，优先级高

  ```html
    <link rel="subresource" href="critical/app.js">
  ```

  - 预渲染

    **用 `prerender` 来让浏览器在后台事先渲染好整个页面**

  ```html
    <link rel="prerender" href="checkout.html">
  ```

  







## 动态插入script

### 执行内联脚本



```js
var script = document.createElement('script');
console.log("script start");
script.text = 'console.log("foo")';
// 等价于
// script.text = 'console.log("foo")';
// script.innerText = 'console.log("foo")';
// script.innerHTML = 'console.log("foo")';
document.body.appendChild(script);
console.log("script end");
```

 `.appendChild` 阻塞的，需要等到JS运行结束才返回。

```
script start
foo
script end
```



### 执行外部脚本

外部脚本的插入是异步的不会阻塞 DOM 解析

```js
var script = document.createElement('script');
script.src = 'foo.js';
document.body.appendChild(script);
```



> 此外有一个细节可能需要注意：一旦设置了 `src` 属性，`<script>` 标签本身的所有内容就不会再被执行了。

### innerHTML

```js
document.body.innerHTML = '<script src="foo.js"></script>'
document.body.innerHTML = '<script>console.log("foo")</script>'
```





## 异步加载

### 异步加载脚本：插入外链脚本标签

加载中

浏览器“载入中”的标志会让用户感觉网页慢！load事件发生时，`载入中`消失

可以设置在load之后再去获取js，这时不会再阻塞DOM 的渲染了

```js
document.addEventListener('load', function(){
    var s = document.createElement('script');
    s.src = "/will-not-stop-loading.js";
    document.body.appendChild(s);
});
```

### 异步加载脚本：XHR+Eval

XHR下载整个脚本，`eval()`来执行这个脚本。

`eval()`是不安全的，可以创建一个`<script>`标签，并把XHR获取的脚本注入进去。 再把 `<script>` 标签插入 DOM 它的内容就会执行。

```js
$.get('/path/to/sth.js').done(eval);
```

### 异步加载脚本：Defer/Async

```html
<script src="one.js" async></script>     <!--异步执行-->
<script src="one.js" defer></script>     <!--延迟执行--> 
```

![defer vs async](assets/0.HTML/acyn-vs-defer.jpg)



- 默认：遇到JS时，HTML停止解析，立即去下载和执行JS

-  `defer`延迟执行：先下载，等HTML解析完毕（`DOMContentLoaded`事件）再执行

-  `async`：下载完JS 后，再停下解析，立马去执行JS



### 资源载入事件

事件：

- 现代浏览器**只会**触发`onload`和`onerror`，

- IE下**只会**触发`onreadystatechange`

```js
createScript('https://cdn.jsdelivr.net/npm/react@15.4.0/dist/react.js');
createScript('https://harttle.land/this/will/404.js');
function createScript(src){
    var el = document.createElement('script');
    el.src = src;
    el.onload = () => console.log('load', el);
    el.onerror = () => console.log('error', el);
    el.onreadystatechange = () => console.log('readystatechange', el);
    document.body.append(el);
}
```





> (1)  顺序 
>
>  ①  解析HTML结构； 
>
>  ②  加载外部脚本和样式表文件； 
>
>  ③  解析并执行脚本代码； 
>
>  ④  DOM树构建完成；//DOMContentLoaded 
>
>  ⑤  加载图片等外部文件； 
>
>  ⑥  页面加载完毕。//load
>
> DOMContentLoaded事件：意思是HTML**下载、解析**完毕之后就触发。（ DOM树构建完成）
>
> Load：html、css、js、图片等都已完成**加载**



# 判断用户的设备

`navigator.userAgent`对象

```js
if (browser.versions.mobile) {//判断是否是移动设备打开。browser代码在下面
        var ua = navigator.userAgent.toLowerCase();//获取判断用的对象
        if (ua.match(/MicroMessenger/i) == "micromessenger") {
                //在微信中打开
        }
        if (ua.match(/WeiBo/i) == "weibo") {
                //在新浪微博客户端打开
        }
        if (ua.match(/QQ/i) == "qq") {
                //在QQ空间打开
        }
        if (browser.versions.ios) {
                //是否在IOS浏览器打开
        } 
        if(browser.versions.android){
                //是否在安卓浏览器打开
        }
} else {
        //否则就是PC浏览器打开
}
```





# 性能监控

http://www.alloyteam.com/2020/01/14184/

https://juejin.cn/post/6911472693405548557

## 监控内容：

1. 响应速度：页面初始访问速度 + 交互响应（动画）速度
2. 页面稳定性：页面出错率
3. 外部服务调用：网络请求访问速度



## 1. 页面访问速度

**白屏、首屏、可交互时间**



![1](assets/0.HTML/006tNbRwgy1gah51k3lg8j31bi0gg45d.jpg)



| 体验 |                                 |
| ---- | ------------------------------- |
| 出现 | FP，初次绘制、FCP，初次内容绘制 |
| 可用 | FMP、初次有意义绘制             |
| 能用 | TTI，响应时间                   |
| 爽   | 长任务                          |



1）FP

window.performance 







报错上传：重写window.onerror

# 前端性能优化



1. **传得少**

   1. 压缩
      1. Gzip
      2. JS、CSS：uglify压缩（去除log）
      3. 图片：icon font、svg、雪碧图、base64存进local storage
   2. 缓存
      1. 缓存：Expires、Cache-Control、Etag、Last-Modified
   3. 请求控制
      1. 防抖节流
      2. 文件不大于25K
      3. 懒加载
         1. vue-router使用路由懒加载
         2. 图片懒加载
      4. Cookie瘦身

   

2. **传的快**

   1. 单页面6个请求限制：减少HTTP请求、使用多域名、CDN

   2. 使用外部JS、CSS

   3. defer、async延迟加载、异步加载

   4. 预查询（减少DNS查询）、预加载

3. **流畅**

   1. 渲染

      1. 加载顺序CSS放在头部，JS放底部、内联关键样式

      2. 减少DOM 数量、DOM操作

         1. 减少重绘重排（只composting）

            1. 读写分离

               - 缓存布局（大小）信息
               - 别边读边写

            2. 属性集中一次修改

               `el.style.cssText += "; left: " + left + "px; top: " + top + "px;";`

            3. DOM离线修改，后替换

               用`documentFragment`对象在内存里操作DOM

            4. 绝对定位

               位置固定，开销小，可以把动画放在这上面

            5. opacity、z-index新建图层，减少composting

      3. CSS优化

         1. 内联首屏关键CSS
         2. 选择器优化
         3. 不使用@import，用 link

   2. 动画

      1. requestAnimationFrame

   3. 长列表

      1. raf+Fragment

   4. 心理控制：加载动画、骨架

4. **开发**

   1. vue
      1. v-if和v-show
      2. watch和computed
      3. v-for必须添加key
      4. beforeDestroy销毁定时器
   2. wepack
      1. 开发快
         1. 编译快
            1. 缓存
            2. 文件检索：loader 范围、常用后缀排序、别名映射
            3. 多线程happypack
            4. treeshaking
            5. 提前打包DllPlugin
            6. 无依赖的库跳过解析module.noParse
      2. 生产快
         1. 业务和依赖分离打包
         2. 按需加载
         3. Scope Hoisting
            将所有模块的代码按照引用顺序放在一个函数作用域里
         4. Tree Shaking
            删除未使用代码、CSS





## 性能优化

1. 网络传输

   1. H2

      1. 多路复用
      2. 二进制压缩
      3. 头部压缩
      4. 服务端推送（不用开，因为资源怎么加载在nginx那边配置）
      5. ...

   2. CDN

      1. 缓存策略调优
         1. 客户端缓存
            1. 强缓存
            2. 协商缓存
         2. CDN节点缓存
            1. 缓存时间
            2. 缓存刷新
            3. 缓存预热

   3. DNS预解析

      `<link rel="dns-prefetch" href="//example.com">`

   4. 预连接(提前建立连接)

      `<link rel="preconnect" href="//example.com">`

      ` <link rel="preconnect" href="//cdn.example.com" crossorigin>`

   5. 域名收敛

      把⻚面资源部署在尽可能少的域名下。

      随着时代发展『域名发散』逐渐落后，使用『域名收敛』配合 H2，可以最大化的节省 DNS 解析、TCP 建连等网络成本，更好的发挥其多路复用的优势，大幅提升⻚面性能。

   6. brotli压缩

      谷歌2015发布，比gzip，更高压缩比、性能

   7. 优化 https

      性能拉垮原因：多次握手、TLS相关算法计算

      1. session resume

         昂贵的计算结果放session中复用

      2. OCSP Stampling（RFC6066 第 8 节）

      3. TLS 1.3

         只需要一次往返（1-RTT）即可完成握手

      4. TCP Fast Open

      5. HSTS（强制HTTPS）

2. 缓存

   1. DNS缓存
      1. 浏览器缓存->操作系统缓存->DNS缓存
   2. 宿主缓存
   3. 运行时缓存

3. 资源

4. 运行时

5. 接口

